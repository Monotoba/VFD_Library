// ============================================================================
// Filename: VFD.cpp
// Version: 1.0.0
// Date: 2025-09-12
// Author: Randall Morgan
// Maintainer: rmorgan62@gmail.com
// Description:
//   Implementation file for the VFD library to control the Noritake 20S401DA1
//   Vacuum Fluorescent Display (4x20). Provides functionality for:
//     - Basic display commands (clear, cursor positioning, brightness)
//     - Custom glyph definition and usage
//     - BIGASCII character rendering (A-Z, 0-9)
//     - Horizontal and vertical scrolling of BIGASCII text
// ============================================================================

#include "VFD.h"

// --- BIGASCII letters and digits ---
const char* VFD::BIGASCII[36][4] = {
    {" ███ ","█   █","█████","█   █"}, // A
    {"████ ","█   █","████ ","█   █"}, // B
    {" ████","█    ","█    "," ████"}, // C
    {"████ ","█   █","█   █","████ "}, // D
    {"█████","█    ","████ ","█    "}, // E
    {"█████","█    ","████ ","█    "}, // F
    {" ████","█    ","█ ███"," ████"}, // G
    {"█   █","█   █","█████","█   █"}, // H
    {"█████","  █  ","  █  ","█████"}, // I
    {"  ███","   █ ","█  █ "," ██  "}, // J
    {"█   █","█  █ ","███  ","█  █ "}, // K
    {"█    ","█    ","█    ","█████"}, // L
    {"█   █","██ ██","█ █ █","█   █"}, // M
    {"█   █","██  █","█ █ █","█  ██"}, // N
    {" ███ ","█   █","█   █"," ███ "}, // O
    {"████ ","█   █","████ ","█    "}, // P
    {" ███ ","█   █","█  ██"," ████"}, // Q
    {"████ ","█   █","████ ","█  █ "}, // R
    {" ████","█    "," ███ ","    █"}, // S
    {"█████","  █  ","  █  ","  █  "}, // T
    {"█   █","█   █","█   █"," ███ "}, // U
    {"█   █","█   █"," █ █ ","  █  "}, // V
    {"█   █","█ █ █","██ ██","█   █"}, // W
    {"█   █"," █ █ "," █ █ ","█   █"}, // X
    {"█   █"," █ █ ","  █  ","  █  "}, // Y
    {"█████","   █ ","  █  ","█████"}, // Z
    {" ███ ","█  ██","█ █ █"," ███ "}, // 0
    {"  █  "," ██  ","  █  ","█████"}, // 1
    {"████ ","   █ "," █   ","█████"}, // 2
    {"████ ","   █ ","   █ ","████ "}, // 3
    {"█  █ ","█  █ ","█████","   █ "}, // 4
    {"█████","█    ","████ ","    █"}, // 5
    {" ███ ","█    ","████ "," ███ "}, // 6
    {"█████","   █ ","  █  "," █   "}, // 7
    {" ███ ","█ █ █"," ███ "," ███ "}, // 8
    {" ███ ","█ █ █"," ████","   █ "}  // 9
};

// -------------------- Constructor --------------------
VFD::VFD(HardwareSerial &serial){
    _serial = &serial;
}

// -------------------- Begin --------------------
void VFD::begin(long baud){
    _serial->begin(baud);
}

// -------------------- Low-level helpers --------------------
void VFD::send(const char* text){
    _serial->print(text);
}

void VFD::cmd(uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4){
    uint8_t buf[4] = {b1, b2, b3, b4};
    _serial->write(buf,4);
}

// -------------------- Basic commands --------------------
void VFD::clear(){ cmd(ESC,'C'); delay(50); }
void VFD::home(){ cmd(ESC,'H'); }
void VFD::setCursor(uint8_t row,uint8_t col){ cmd(ESC,'Q',row,col); }
void VFD::setBrightness(uint8_t level){ cmd(ESC,'L',constrain(level,1,4)); }
void VFD::write(const char* text){ send(text); }

// -------------------- Custom glyphs --------------------
void VFD::defineGlyph(uint8_t slot,const uint8_t bitmap[8]){
    if(slot>7) return;
    cmd(ESC,'&',0,slot);
    _serial->write(bitmap,8);
}
void VFD::writeGlyph(uint8_t slot){ _serial->write(slot); }

// -------------------- BIGASCII single-word --------------------
void VFD::writeBigMsg(const char* msg,bool center,bool vscroll){
    char line[4][41]; // 4 rows max, up to 40 chars including spaces
    memset(line, ' ', sizeof(line));
    size_t len=strlen(msg);
    for(size_t i=0;i<len;i++){
        char c=toupper(msg[i]);
        int index=-1;
        if(c>='A' && c<='Z') index=c-'A';
        else if(c>='0' && c<='9') index=c-'0'+26;
        else continue;
        for(int row=0;row<4;row++){
            strcat(line[row], BIGASCII[index][row]);
            strcat(line[row], " ");
        }
    }
    // Centering
    for(int row=0;row<4;row++){
        if(center){
            int l=strlen(line[row]);
            int pad=(20-l)/2;
            if(pad>0){
                char tmp[41];
                sprintf(tmp,"%*s%s",pad,"",line[row]);
                strcpy(line[row],tmp);
            }
        }
        setCursor(row+1,1);
        char out[21];
        strncpy(out,line[row],20);
        out[20]=0;
        write(out);
    }
    // TODO: vscroll not implemented for simplicity
}

// -------------------- Horizontal scroll BIGASCII --------------------
void VFD::hScrollBigMsg(const char* msg,unsigned long delayMs){
    char line[4][128]; // large enough buffer
    memset(line,' ',sizeof(line));
    size_t len=strlen(msg);
    for(size_t i=0;i<len;i++){
        char c=toupper(msg[i]);
        int index=-1;
        if(c>='A' && c<='Z') index=c-'A';
        else if(c>='0' && c<='9') index=c-'0'+26;
        else continue;
        for(int row=0;row<4;row++){
            strcat(line[row],BIGASCII[index][row]);
            strcat(line[row]," ");
        }
    }
    // pad 20 spaces for smooth scroll
    for(int row=0;row<4;row++){
        strcat(line[row],"                    ");
    }
    size_t totalLen=strlen(line[0]);
    for(size_t offset=0;offset<totalLen-20;offset++){
        for(int row=0;row<4;row++){
            setCursor(row+1,1);
            char out[21];
            strncpy(out,line[row]+offset,20);
            out[20]=0;
            write(out);
        }
        delay(delayMs);
    }
}

// -------------------- Vertical scroll BIGASCII --------------------
void VFD::vScrollBigMsg(const char* msg,unsigned long delayMs){
    // Split words
    char line[128][41]; // up to 128 rows, each 40 chars
    int rowCount=0;
    char tmp[32];
    strcpy(tmp,msg);
    char* token=strtok(tmp," ");
    while(token){
        size_t len=strlen(token);
        char buf[4][41];
        memset(buf,' ',sizeof(buf));
        for(size_t i=0;i<len;i++){
            char c=toupper(token[i]);
            int index=-1;
            if(c>='A' && c<='Z') index=c-'A';
            else if(c>='0' && c<='9') index=c-'0'+26;
            else continue;
            for(int r=0;r<4;r++){
                strcat(buf[r],BIGASCII[index][r]);
                strcat(buf[r]," ");
            }
        }
        // copy buf into line
        for(int r=0;r<4;r++){
            strcpy(line[rowCount++],buf[r]);
        }
        // blank row between words
        strcpy(line[rowCount++],"                    ");
        token=strtok(NULL," ");
    }
    // scroll vertically
    for(int start=0;start<=rowCount-4;start++){
        for(int r=0;r<4;r++){
            setCursor(r+1,1);
            char out[21];
            strncpy(out,line[start+r],20);
            out[20]=0;
            write(out);
        }
        delay(delayMs);
    }
}

// Utility: Try different baudrates and send test message
void VFDLib::findBaudrates(const long* rates, size_t count, uint16_t delayMs) {
    for (size_t i = 0; i < count; i++) {
        long testBaud = rates[i];
        begin(testBaud);

        clear();
        setCursor(0, 0);
        print("Testing");
        setCursor(0, 1);
        print("Baudrate ");
        _serial.print(testBaud);

        delay(delayMs);
    }
}

